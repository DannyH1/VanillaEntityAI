<?php
declare(strict_types=1);
namespace jasonwynn10\VanillaEntityAI\entity\hostile;

use pocketmine\entity\Monster;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\event\entity\ExplosionPrimeEvent;
use pocketmine\level\Explosion;
use pocketmine\level\Position;
use pocketmine\Player;

class Creeper extends Monster implements CustomMonster {
	public const NETWORK_ID = self::CREEPER;

	public $width = 0.7;
	public $height = 1.7;

	/** @var Position */
	private $target;
	private $bombTime = 0;
	public $speed = 0.9;

	public function initEntity() : void {
		parent::initEntity(); // TODO: Change the autogenerated stub
	}

	public function onUpdate(int $currentTick) : bool {
		$tickDiff = $currentTick - $this->lastUpdate;

		if($this->target !== null) {
			$x = $this->target->x - $this->x;
			$y = $this->target->y - $this->y;
			$z = $this->target->z - $this->z;

			$diff = abs($x) + abs($z);

			if($this->target instanceof Player and $this->target->distance($this) <= 3.5) {
				$this->bombTime += $tickDiff;
				if($this->bombTime >= 30 and $this->isAlive()) {
					$this->explode();
					return false;
				}
			}else{
				$this->bombTime -= $tickDiff;
				if($this->bombTime < 0) {
					$this->bombTime = 0;
				}
			}
			if($diff > 0) {
				$this->motion->x = $this->getSpeed() * 0.15 * ($x / $diff);
				$this->motion->z = $this->getSpeed() * 0.15 * ($z / $diff);
				$this->yaw = rad2deg(-atan2($x / $diff, $z / $diff));
			}
			$this->pitch = $y == 0 ? 0 : rad2deg(-atan2($y, sqrt($x * $x + $z * $z)));
		}else{
			$this->bombTime = 0;
		}

		return parent::onUpdate($currentTick);
	}

	public function explode() {
		$this->server->getPluginManager()->callEvent($ev = new ExplosionPrimeEvent($this, 3)); // TODO force = 3 for regular creeper, 6 if charged

		if(!$ev->isCancelled()) {
			$explosion = new Explosion($this, $ev->getForce(), $this);
			$ev->setBlockBreaking(true); // TODO: mob griefing config
			if($ev->isBlockBreaking()) {
				$explosion->explodeA();
			}
			$explosion->explodeB();
		}
		$this->flagForDespawn();
	}

	/**
	 * @param int $tickDiff
	 *
	 * @return bool
	 */
	public function entityBaseTick(int $tickDiff = 1) : bool {
		// TODO: set target to player if in range and no other player target is set
		return parent::entityBaseTick($tickDiff);
	}

	/**
	 * Entity gets attacked by another entity / explosion or something similar
	 *
	 * @param EntityDamageEvent $source the damage event
	 */
	public function attack(EntityDamageEvent $source) : void {
		parent::attack($source);
		if(!$this->target instanceof Player)
			if($source instanceof EntityDamageByEntityEvent) {
				$damager = $source->getDamager();
				if($damager instanceof Player and $damager->isSurvival() and $this->distance($damager) <= 16 and abs($this->y - $damager->y) <= 4)
					$this->target = $damager;
				elseif(!$damager instanceof Player and $this->distance($damager) <= 16 and abs($this->y - $damager->y) <= 4)
					$this->target = $damager;
			}
	}

	public function getSpeed() : float {
		return $this->speed;
	}

	/**
	 * @return array
	 */
	public function getDrops() : array {
		return parent::getDrops(); // TODO: Change the autogenerated stub
	}

	/**
	 * @return string
	 */
	public function getName() : string {
		return "Creeper";
	}

	public function getTarget() : ?Position {
		return $this->target;
	}
}